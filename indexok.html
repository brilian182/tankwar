<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<title>3D Tank Shooter</title>
<style>
  body { margin: 0; overflow: hidden; background: #000; }
  #info {
    position: absolute;
    top: 10px;
    left: 10px;
    color: white;
    font-family: Arial;
    z-index: 10;
  }
</style>
</head>
<body>

<div id="info">
  ðŸŽ® <b>3D Tank Shooter</b><br>
  W/S: Move &nbsp; A/D: Turn &nbsp; SPACE: Shoot
</div>

<script src="https://cdn.jsdelivr.net/npm/three@0.160.0/build/three.min.js"></script>

<script>
/* ================= SCENE ================= */
const scene = new THREE.Scene();
scene.background = new THREE.Color(0x202020);

const camera = new THREE.PerspectiveCamera(
  75,
  window.innerWidth / window.innerHeight,
  0.1,
  1000
);

const renderer = new THREE.WebGLRenderer({ antialias: true });
renderer.setSize(window.innerWidth, window.innerHeight);
document.body.appendChild(renderer.domElement);

/* ================= LIGHT ================= */
const light = new THREE.DirectionalLight(0xffffff, 1);
light.position.set(10, 20, 10);
scene.add(light);
scene.add(new THREE.AmbientLight(0x404040));

/* ================= GROUND ================= */
const ground = new THREE.Mesh(
  new THREE.PlaneGeometry(200, 200),
  new THREE.MeshStandardMaterial({ color: 0x2e8b57 })
);
ground.rotation.x = -Math.PI / 2;
scene.add(ground);

/* ================= TANK ================= */
const tank = new THREE.Group();

// body
const body = new THREE.Mesh(
  new THREE.BoxGeometry(2, 1, 3),
  new THREE.MeshStandardMaterial({ color: 0x556b2f })
);
tank.add(body);

// turret
const turret = new THREE.Mesh(
  new THREE.CylinderGeometry(0.5, 0.5, 1, 16),
  new THREE.MeshStandardMaterial({ color: 0x6b8e23 })
);
turret.rotation.z = Math.PI / 2;
turret.position.y = 0.8;
tank.add(turret);

tank.position.y = 0.5;
scene.add(tank);

/* ================= ENEMY ================= */
const enemies = [];
for (let i = 0; i < 5; i++) {
  const enemy = new THREE.Mesh(
    new THREE.BoxGeometry(2, 2, 2),
    new THREE.MeshStandardMaterial({ color: 0xff0000 })
  );
  enemy.position.set(
    Math.random() * 80 - 40,
    1,
    Math.random() * 80 - 40
  );
  scene.add(enemy);
  enemies.push(enemy);
}

/* ================= CONTROLS ================= */
const keys = {};
window.addEventListener("keydown", e => keys[e.code] = true);
window.addEventListener("keyup", e => keys[e.code] = false);

/* ================= BULLETS ================= */
const bullets = [];

function shoot() {
  const bullet = new THREE.Mesh(
    new THREE.SphereGeometry(0.2, 8, 8),
    new THREE.MeshStandardMaterial({ color: 0xffff00 })
  );
  bullet.position.copy(tank.position);
  bullet.position.y = 0.8;

  bullet.direction = new THREE.Vector3(
    Math.sin(tank.rotation.y),
    0,
    Math.cos(tank.rotation.y)
  );
  scene.add(bullet);
  bullets.push(bullet);
}

/* ================= GAME LOOP ================= */
function animate() {
  requestAnimationFrame(animate);

  // movement
  if (keys["KeyW"]) {
    tank.position.x += Math.sin(tank.rotation.y) * 0.2;
    tank.position.z += Math.cos(tank.rotation.y) * 0.2;
  }
  if (keys["KeyS"]) {
    tank.position.x -= Math.sin(tank.rotation.y) * 0.2;
    tank.position.z -= Math.cos(tank.rotation.y) * 0.2;
  }
  if (keys["KeyA"]) tank.rotation.y += 0.05;
  if (keys["KeyD"]) tank.rotation.y -= 0.05;

  // shoot
  if (keys["Space"]) {
    keys["Space"] = false;
    shoot();
  }

  // bullets movement
  bullets.forEach((b, i) => {
    b.position.add(b.direction.clone().multiplyScalar(0.6));

    enemies.forEach((e, ei) => {
      if (b.position.distanceTo(e.position) < 1.5) {
        scene.remove(e);
        enemies.splice(ei, 1);
      }
    });

    if (b.position.length() > 200) {
      scene.remove(b);
      bullets.splice(i, 1);
    }
  });

  // camera follow
  camera.position.set(
    tank.position.x - Math.sin(tank.rotation.y) * 6,
    5,
    tank.position.z - Math.cos(tank.rotation.y) * 6
  );
  camera.lookAt(tank.position);

  renderer.render(scene, camera);
}

animate();

/* ================= RESIZE ================= */
window.addEventListener("resize", () => {
  camera.aspect = window.innerWidth / window.innerHeight;
  camera.updateProjectionMatrix();
  renderer.setSize(window.innerWidth, window.innerHeight);
});
</script>

</body>
</html>
