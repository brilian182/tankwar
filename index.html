<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<title>3D Tank Shooter</title>
<style>
body {
  margin: 0;
  overflow: hidden;
  font-family: Arial, sans-serif;
}

/* LOADING SCREEN */
#loading {
  position: fixed;
  inset: 0;
  background: #111;
  color: white;
  display: flex;
  flex-direction: column;
  justify-content: center;
  align-items: center;
  z-index: 9999;
}

#startBtn {
  margin-top: 20px;
  padding: 12px 24px;
  font-size: 18px;
  cursor: pointer;
}
</style>
</head>
<body>

<div id="loading">
  <h1>ðŸš€ 3D Tank Shooter</h1>
  <p>Click START to play</p>
  <button id="startBtn">START GAME</button>
</div>

<script src="https://cdn.jsdelivr.net/npm/three@0.160.0/build/three.min.js"></script>

<script>
document.getElementById("startBtn").onclick = () => {
  document.getElementById("loading").style.display = "none";
  startGame();
};

function startGame() {

try {

/* ================= AUDIO ================= */
const shootSound = new Audio("shoot.wav");
const explodeSound = new Audio("explosion.mp3");

/* ================= SCENE ================= */
const scene = new THREE.Scene();
scene.background = new THREE.Color(0x202020);

const camera = new THREE.PerspectiveCamera(
  75,
  window.innerWidth / window.innerHeight,
  0.1,
  1000
);

const renderer = new THREE.WebGLRenderer({ antialias: true });
renderer.setSize(window.innerWidth, window.innerHeight);
document.body.appendChild(renderer.domElement);

/* ================= LIGHT ================= */
scene.add(new THREE.AmbientLight(0x404040));
const light = new THREE.DirectionalLight(0xffffff, 1);
light.position.set(10, 20, 10);
scene.add(light);

/* ================= GROUND ================= */
const ground = new THREE.Mesh(
  new THREE.PlaneGeometry(200, 200),
  new THREE.MeshStandardMaterial({ color: 0x2e8b57 })
);
ground.rotation.x = -Math.PI / 2;
scene.add(ground);

/* ================= TANK ================= */
const tank = new THREE.Group();

const body = new THREE.Mesh(
  new THREE.BoxGeometry(2, 1, 3),
  new THREE.MeshStandardMaterial({ color: 0x556b2f })
);
tank.add(body);

const turret = new THREE.Mesh(
  new THREE.CylinderGeometry(0.5, 0.5, 1, 16),
  new THREE.MeshStandardMaterial({ color: 0x6b8e23 })
);
turret.rotation.z = Math.PI / 2;
turret.position.y = 0.8;
tank.add(turret);

tank.position.y = 0.5;
scene.add(tank);

/* ================= ENEMY ================= */
const enemies = [];
for (let i = 0; i < 5; i++) {
  const enemy = new THREE.Mesh(
    new THREE.BoxGeometry(2, 2, 2),
    new THREE.MeshStandardMaterial({ color: 0xff0000 })
  );
  enemy.position.set(Math.random()*80-40,1,Math.random()*80-40);
  scene.add(enemy);
  enemies.push(enemy);
}

/* ================= CONTROLS ================= */
const keys = {};
window.addEventListener("keydown", e => keys[e.code] = true);
window.addEventListener("keyup", e => keys[e.code] = false);

/* ================= BULLETS ================= */
const bullets = [];
let lastShot = 0;
const fireRate = 300;

function shoot() {
  const now = Date.now();
  if (now - lastShot < fireRate) return;
  lastShot = now;

  shootSound.currentTime = 0;
  shootSound.play().catch(()=>{});

  const bullet = new THREE.Mesh(
    new THREE.SphereGeometry(0.2, 8, 8),
    new THREE.MeshStandardMaterial({ color: 0xffff00 })
  );
  bullet.position.copy(tank.position);
  bullet.position.y = 0.8;

  bullet.direction = new THREE.Vector3(
    Math.sin(tank.rotation.y),
    0,
    Math.cos(tank.rotation.y)
  );

  scene.add(bullet);
  bullets.push(bullet);
}

/* ================= LOOP ================= */
function animate() {
  requestAnimationFrame(animate);

  if (keys["KeyW"]) {
    tank.position.x += Math.sin(tank.rotation.y) * 0.2;
    tank.position.z += Math.cos(tank.rotation.y) * 0.2;
  }
  if (keys["KeyS"]) {
    tank.position.x -= Math.sin(tank.rotation.y) * 0.2;
    tank.position.z -= Math.cos(tank.rotation.y) * 0.2;
  }
  if (keys["KeyA"]) tank.rotation.y += 0.05;
  if (keys["KeyD"]) tank.rotation.y -= 0.05;

  if (keys["Space"]) shoot();

  bullets.forEach((b, i) => {
    b.position.add(b.direction.clone().multiplyScalar(0.6));

    enemies.forEach((e, ei) => {
      if (b.position.distanceTo(e.position) < 1.5) {
        explodeSound.currentTime = 0;
        explodeSound.play().catch(()=>{});
        scene.remove(e);
        enemies.splice(ei, 1);
      }
    });

    if (b.position.length() > 200) {
      scene.remove(b);
      bullets.splice(i, 1);
    }
  });

  camera.position.set(
    tank.position.x - Math.sin(tank.rotation.y) * 6,
    5,
    tank.position.z - Math.cos(tank.rotation.y) * 6
  );
  camera.lookAt(tank.position);

  renderer.render(scene, camera);
}

animate();

/* ================= RESIZE ================= */
window.addEventListener("resize", () => {
  camera.aspect = window.innerWidth / window.innerHeight;
  camera.updateProjectionMatrix();
  renderer.setSize(window.innerWidth, window.innerHeight);
});

} catch (err) {
  alert("Game error: " + err.message);
  console.error(err);
}

}
</script>
</body>
</html>
